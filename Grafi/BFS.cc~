void BFS(Graph g, int s){
  printf("================= \n");
  printf("Breadth First Search algorithm\n");
  printf("================= \n");
  
  printf("selected vertex number %i (counting from 1) \n", s);
  s=s-1;
  int *d = (int*) malloc(SIZE*sizeof(int) );
  int *pi = (int*) malloc(SIZE*sizeof(int) );
  char *color = (char*) malloc(SIZE*sizeof(char) );
  int q[SIZE]={0};

  printf("vector q inizialmente:\n");
  for(int i=0; i<SIZE; i++){
   printf("%i ",q[i]);
   }
  printf("\n");
  int in = 0;//increment of the queue
  int u;
 
  // initialization
   for(int i=0; i<SIZE; i++){
     if (i!= s){
     color[i] = 'w';
     d[i] = 999;
     pi[i] = 0;
     }
   }
   color[s] = 'g';
   d[s] = 0;
   pi[s] = 0;

   printf("vector color inizialmente:\n");
   for(int i=0; i<SIZE; i++){
   printf("%c ",color[i]);
   }
   
   printf("\n");
   printf("IN iniziale: %i \n", in );
   q[in] = s;
   in++;
   int out=0;
   printf("OUT iniziale: %i \n", out );
   
   printf("starting while loop \n");
   while (out!=SIZE){
     u = q[out];
     out++;
     printf("u=%i \n", u );
     printf("OUT increm: %i \n", out );
     for(int v=0; v<SIZE; v++){
       if (g.admat[v+SIZE*u]!=0){
	 if (color[v]=='w') {
	   color[v]='g';
	   d[v] = d[u] + 1;
	   pi[v] = u;
	   q[in]=v;
	   in++;
	   printf("IN increm: %i\n",in);
	   printf("printing q:\n");
	   for (int i=0; i<SIZE; i++){
	     printf("q[%i]=%i    ", i, q[i]);
	   }
	   printf("\n");
	 }
       }// end if
       color[u] = 'b';
     }
   }// end while

   printf("color: \n");
    for(int i=0; i<SIZE; i++){
     printf("%c ",color[i]);
   }
   printf("\n");
   printf("dist: \n");
      for(int i=0; i<SIZE; i++){
     printf("%i ",d[i]);
   }
   printf("\n");
   printf("pi: \n");
   for(int i=0; i<SIZE; i++){
     printf("%i ",pi[i]);
   }
   printf("\n");
   
   
   free(d);
   free(pi);
   free(color);
}
